//
// Created by phatt on 11/28/25.
//
#pragma once
#include "Core.h"

namespace ZPG
{
    namespace Math
    {
        inline v3 Bezier3(const v3& P0, const v3& P1, const v3& P2, const v3& P3, float t)
        {
            float mt = 1 - t;
            return ( powf(mt, 3) * P0 )
                 + ( 3 * powf(mt, 2) * t * P1 )
                 + ( 3 * mt * powf(t, 2) * P2 )
                 + ( powf(t, 3) * P3 );
        }

        inline v3 TangentBezier3(const v3& P0, const v3& P1, const v3& P2, const v3& P3, float t)
        {
            float mt = 1 - t;
            return ( 3 * mt * mt   * (P1 - P0) )
                 + ( 6 * mt * t    * (P2 - P1) )
                 + ( 3 * t  * t    * (P3 - P2) );
        }

        inline m4 RotationMatFromDirection(const v3& direction)
        {
            using namespace glm;

            v3 z = normalize(direction);
            v3 r = v3(0,1,0);

            float ZdotR = dot(z, r);

            if (abs(ZdotR) > 0.999f) {
                r = v3(0,0,0);
            }

            v3 x = normalize(cross(r, z));
            v3 y = cross(z, x);

            // object is aligned by these basis vectors
            m4 R(1.0f);
            R[0] = v4(x, 0.0f);
            R[1] = v4(y, 0.0f);
            R[2] = v4(z, 0.0f);

            return R;
        }

    /*
       vx vy
    x [1/sqrt(2)  0][1] = [1/sqrt(2)]
    y [1/sqrt(2)  1][1]   [1/sqrt(2) + 1]

    [1 0 0 0][1]
    [1 1 0 0][1] = 
    [0 0 1 0][1]
    [0 0 0 1][1]


*/
    }
}
