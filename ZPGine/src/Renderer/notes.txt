1. Scene builds RenderCommands, one per mesh

2. Renderer sorts them into per-pass queues








class Material 
{
    Texture2D albedo
    Texture2D roughness
    Texture2D metallic
    ...

    // Should material know about how to render itself or should this be only the concern of the renderer?
    // Pipeline pipeline
}

class Mesh
{
    VAO vao
    Material material
    mat4 local_transform
}

class Model 
{
    list<Mesh> meshes
}

class Entity 
{
    Model model
    mat4 transform
    int entity_id

    // Should entity have mobility attribute or should only the renderer know about it?
    // Mobility mobility
}

enum Mobility
{
    Static
    Dynamic
}

enum RenderFeature : uint32_t {
    CastsShadow      = 1 << 0,
    DepthPrepass     = 1 << 1,
    ReceiveLighting  = 1 << 2,
    Transparent      = 1 << 3
}

enum RenderPath
{
    Deferred  // uses the deferred shader program
    Forward   // can have it's own shader program, if non then default forward shader program is used
}

struct Pipeline
{
    RenderPath render_path
    ShaderProgram* program = nullptr
}

struct RenderCommand
{
    Mesh mesh 
    mat4 transform 
    int entity_id
    Mobility mobility 
    Pipeline pipeline

    static FromEntity(Entity entity, Mobility mobility, Pipeline pipeline) -> list<RenderCommand> {
        list<RenderCommand> cmds

        foreach (mesh : entity.model)
        {
            RenderCommand cmd
            cmd.mesh = mesh
            cmd.entity_id = entity.entity_id
            cmd.transform = entity.transform * mesh.local_transform
            cmd.mobility = mobility
            cmd.pipeline = pipeline

            cmds.push(pipeline)
        }

        return cmds
    }
}

class Renderer
{
    BeginRender(Camera cam)
    EndRender()

    Submit(RenderCommand cmd)

    Reset()  // clears the batches

    RenderBatches static_batches;
    RenderBatches dynamic_batches;
}

class Scene
{
    OnAttach() {
        static_emissive_entities.push(new Entity(Mobility::Static, ModelCatalog::Get(...)))
        static_emissive_entities.push(new Entity(Mobility::Static, ...))
        static_entities.push(new Entity(Mobility::Dynamic, ...))
        ...
        static_entities.push(new Entity(Mobility::Dynamic, ...))

        foreach (entity : static_emissive_entities)
        {
            foreach (mesh : entity.model)
            {
                RenderCommand cmd
                cmd.mobility = entity.mobility
                cmd.mesh = mesh
                cmd.transform = entity.transform * mesh.local_transform
                cmd.entity_id = entity.entity_id
                cmd.pipeline = {
                    render_path = RenderPath::Forward
                    program = ShaderProgramCatalog::Get('emissive')
                }

                Renderer::Submit(cmd)
            }
        }

        foreach (entity : static_entities)
        {
            foreach (mesh : entity.model)
            {
                RenderCommand cmd
                cmd.mobility = entity.mobility
                cmd.mesh = mesh
                cmd.transform = entity.transform * mesh.local_transform
                cmd.entity_id = entity.entity_id
                cmd.pipeline = {
                    render_path = RenderPath::Forward
                    program = nullptr   // use the default
                }

                Renderer::Submit(cmd)
            }
        }
    }

    OnUpdate() {
        Renderer::BeginRender(camera) 
        for (entity : dynamic_entities)
        {
            cmd = RenderCommand.FromEntity(entity, Mobility::Dynamic, Pipeline{ RenderPath::Deferred })
            Renderer::Submit(cmd)
        }

        Renderer::EndRender()
    }

    Camera camera
}
